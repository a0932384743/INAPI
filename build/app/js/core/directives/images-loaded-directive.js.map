{"version":3,"names":[],"mappings":"","sources":["core/directives/images-loaded-directive.js"],"sourcesContent":["(function () {\n  'use strict';\n\n  /**\n   * this directive \"imagesLoaded\" is just a custom version of https://github.com/bimal1331/angular-images-loaded\n   */\n  angular.module('core')\n    .directive('imagesLoaded', imagesLoaded);\n\n  imagesLoaded.$inject = ['$timeout', '$rootScope', '$q'];\n\n  /* jshint unused:false */\n  /* eslint no-unused-vars:0 */\n  /* eslint no-underscore-dangle:0 */\n  /* eslint no-cond-assign:0 */\n  /* eslint no-extra-parens:0 */\n  /* eslint no-shadow:0 */\n  /* eslint \"angular/ng_document_service\":0 */\n  /* global document, Image : false */\n  function imagesLoaded($timeout, $rootScope, $q) {\n    var directive = {}, cache = {},\n        broadcastMessages = {\n          progress: ['imagesLoaded.QUARTER', 'imagesLoaded.HALF', 'imagesLoaded.THREEQUARTERS', 'imagesLoaded.FULL'],\n          successful: 'imagesLoaded.SUCCESS',\n          complete: 'imagesLoaded.FAIL',\n          always: 'imagesLoaded.ALWAYS'\n        };\n\n    // Helper functions\n    function digestPromise(func) {\n      $timeout(func, 0);\n    }\n\n    // Constructors\n    function ImageNode(src, func, inBrowserCache) {\n      this.loaded = undefined;\n      this.loading = true;\n\n      if (!inBrowserCache) {\n        this.node = new Image();\n        this.bind(func);\n        this.node.src = src;\n      } else {\n        this.__onload(func, true);\n      }\n    }\n\n    function ImagesCollection(useProgressEvents) {\n      this.imagesCount = 0;\n      this.imagesLoaded = 0;\n      this.imagesFailed = 0;\n      this.useProgressEvents = useProgressEvents;\n    }\n\n    function compile(tElem, tAttrs) {\n      function link($scope, $element, $attrs) {\n        var descendents = $element[0].childNodes, useProgressEvents = $attrs.useProgressEvents === 'yes',\n            oldImageNodesCount = 0, documentImages = document.images, imageNodes;\n\n        function watchHandler(newVal, oldVal) {\n          var newImageNodesCount, collection;\n\n          // if (newVal === oldVal) {\n          //   return;\n          // }\n\n          imageNodes = $element.find('img');\n          newImageNodesCount = imageNodes.length;\n\n          // if (newImageNodesCount === oldImageNodesCount) {\n          //   return;\n          // }\n\n          oldImageNodesCount = newImageNodesCount;\n\n          collection = new ImagesCollection(useProgressEvents);\n\n          digestPromise(function () {\n            collection.whenImagesLoaded(imageNodes).then(\n              function (data) {\n                $rootScope.$broadcast(data);\n                $rootScope.$broadcast(broadcastMessages.always);\n              },\n              function (error) {\n                angular.noop(error);\n              },\n              function (progress) {\n                if (useProgressEvents) {\n                  $scope.$broadcast('imagesLoaded.PROGRESS', {status: progress});\n                }\n              }\n            );\n          });\n        }\n\n        $scope.$watch(function () {\n          return documentImages.length;\n        }, watchHandler);\n      }\n\n      return link;\n    }\n\n    ImageNode.prototype = {\n      constructor: ImageNode,\n      bind: function (func) {\n        var _this = this;\n        this.node.addEventListener('load', function () {\n          _this.__onload(func, true);\n        }, false);\n        this.node.addEventListener('error', function () {\n          _this.__onload(func, false);\n        }, false);\n      },\n      __onload: function (func, success) {\n        this.loaded = true;\n        this.loading = false;\n\n        if (success && this.node) {\n          delete this.node;\n        }\n\n        func(success);\n      }\n    };\n\n    ImagesCollection.prototype = {\n      constructor: ImagesCollection,\n      whenImagesLoaded: function (imageNodes) {\n        var i = 0, defer = $q.defer(), totalImages = imageNodes.length, _this = this, imgElem, proxyImage;\n        this.imagesCount = totalImages;\n\n        function increment(bool) {\n          var progress;\n\n          if (bool) {\n            _this.imagesLoaded++;\n          } else {\n            _this.imagesFailed++;\n          }\n\n          if (_this.useProgressEvents &&\n            (progress = (_this.imagesLoaded + _this.imagesFailed) / Math.ceil(totalImages / 4)) &&\n            (progress % 1 === 0) && progress < 4) {\n            digestPromise(function () {\n              defer.notify(broadcastMessages.progress[progress - 1]);\n            });\n          }\n\n          if (_this.imagesLoaded + _this.imagesFailed === _this.imagesCount) {\n            digestPromise(function () {\n              defer.notify(broadcastMessages.progress[3]);\n              defer.resolve((_this.imagesFailed > 0) ? broadcastMessages.complete : broadcastMessages.success);\n            });\n          }\n        }\n\n        function check(img) {\n          var source = img.src, cachedElement = cache[source], proxyImage;\n\n          if (cachedElement) {\n            if (cachedElement.loaded) {\n              // Image is in local cache and is loaded\n              increment(true);\n            } else if (cachedElement.loading) {\n              // Image is currently being loaded and it's being checked again before successful load, so we wait for the image to load\n              cachedElement.bind(increment);\n            } else if (cachedElement.loaded === false) {\n              // cachedElement.bind(increment);\n              // cachedElement.node.src = source;\n            }\n          } else if (img.complete && img.naturalWidth > 0) {\n            // Image is not in local cache but is present in browser's cache\n            cache[source] = new ImageNode(source, increment, true);\n          } else {\n            // Image has not been loaded before, so we make a proxy image element and attach load listeners to it\n            cache[source] = new ImageNode(source, increment);\n          }\n        }\n\n        for (i = 0; i < this.imagesCount; i++) {\n          imgElem = imageNodes[i];\n          check(imgElem);\n        }\n\n        return defer.promise;\n      }\n    };\n\n    // Directive configuration object\n    directive = {\n      restrict: 'A',\n      compile: compile\n    };\n\n    return directive;\n  }\n}());\n"],"file":"images-loaded-directive.js"}